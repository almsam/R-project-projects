---
title: "data405a1"
output: html_document
date: "2025-9-25"
---


# Data 405 Assignment 1

## Q1 code:

```{r}

unirand <- function(n, s) {
    # moduluo & multiplier variables
    m <- 30307
    a <- 172

    x <- integer(n)   # raw sequence
    u <- numeric(n)   # normalized seq

    x[1] <- (a * s) %% m
    u[1] <- x[1] / m

    if (n > 1) {
        for (i in 2:n) {
            x[i] <- (a * x[i-1]) %% m
            u[i] <- x[i] / m
        }
    }
    return(u)
}

# s is for seed, n is for number, m is for modulo, a is for multiplier, x is for raw sequence, u is for normalized sequence

```

```{r}

# 10 uniforms using unirand1 with seed = 13
unirand(10, 13)

```

## Q1 discussion:

The maximal cycle length of a multiplicative congruential generator with moduluo m
requires that the 'a' variable be a primitive root modulo m. Since 172 is NOT a primitive root of modulo 30307,
this generator does NOT achieve maximal cycle length (which would be m-1 = 30306)

## Q2 code:

```{r}

unirand2 <- function(n, s) {
    m <- 30323
    a <- 170

    x <- integer(n)
    u <- numeric(n)

    x[1] <- (a * s) %% m
    u[1] <- x[1] / m

    if (n > 1) {
        for (i in 2:n) {
            x[i] <- (a * x[i-1]) %% m
            u[i] <- x[i] / m
        }
    }
    return(u)
}

# s is for seed, n is for number, m is for modulo, a is for multiplier, x is for raw sequence, u is for normalized sequence

```

```{r}

# 10 uniforms using unirand2 with seed = 13
unirand2(10, 42)

```

## Q2 discussion:

For maximal cycle length: 'a' must be a primitive root modulo 'm', & since 170
is not a primitive root modulo on 30323, this generator also does NOT achieve maximal cycle length

## Q3 code:

```{r}

unirand3 <- function(n, s1, s2) {
    u1 <- unirand(n, s1)
    u2 <- unirand2(n, s2)

    u <- u1 + u2 - floor(u1 + u2)  # I believe this is [0,1)
    return(u)
}

```

```{r}

# 10 uniforms using unirand3 with seed = 67
unirand3(10, 13, 9162)

```

## Q3 discussion:

When seeds are s1 = 13 and s2 = 9162, the cycle length exceeds 300000:
 - suppose m1-1 = 30306 and m2-1 = 30322 are the periods of the two individual generators,
 - the LCM will l be 459,469,266 (source https://www.calculatorsoup.com/calculators/math/lcm.php)
 - thus: cycle length >>> 300,000

The resulting numbers look to be approximately uniformly distributed on [0,1)

To check independence, we can lag plot & use a linear model:
```{r}

u <- unirand3(1000, 13, 9162)
plot(u[-1000], u[-1], main="lag plot of unirand3")

# lagged version
u_lag <- u[-length(u)]       # u[1 ... n-1]
u_now <- u[-1]               # u[2 ..... n]

# lin reg
fit <- lm(u_now ~ u_lag)

summary(fit)

```

an intercept close to 0.5 & a slope close to 0 indicates uniform distributed data (0.48 & 0.03 respectively)

but just to be sure, lets up sample from 1000 to 10,000 and check again:

```{r}

u <- unirand3(10000, 13, 9162)
plot(u[-10000], u[-1], main="bigger lag plot of unirand3")

# lagged version
u_lag <- u[-length(u)]       # u[1 ... n-1]
u_now <- u[-1]               # u[2 ..... n]

# lin reg
fit <- lm(u_now ~ u_lag)

summary(fit)

```

slope & intercept of 0.499 & -0.006 respectively show these numbers converge to 0.5 & 0 - indicating uniform distribution
(as what little varrience from 0.5 & 0 is within acceptable noise levels, or simply a corner missing a data point)

## Q4 code:

```{r}

set.seed(67)
u <- unirand3(1000, 13, 9162) # 1000 from uni rand 3

random_forest_test <- function(u, m, bins = 5) {
    n <- length(u) - m + 1
    tuples <- embed(u, m)  # form overlapping m-tuples on each
    # then we partition cube into bins^m cells
    cuts <- lapply(1:m, function(i) cut(tuples[,i], breaks=bins, labels=FALSE))
    idx <- do.call(paste, c(cuts, sep="-"))
    freq <- table(idx)

    # also a chi-square test for uniformity
    chisq.test(freq)
}

# dimension m=10 limit
results <- lapply(2:10, function(m) random_forest_test(u, m))
names(results) <- paste0("m=", 2:10)
results


```

## Q4 discussion:

Results for small m (2–3):

m=2: p=0.3067
p=0.3067 --- no evidence against uniformity.

m=3: p=0.4833
p=0.4833 --- again, no problem.

m>=4: p=1
p=1 --- the test is not valid here due to insufficient sample size for the number of bins


The test works fine for low dimensions (m=2,3) where the sample size is sufficient

for higher dimensions (m ≥ 4), with only 1000 samples, the test likely isn't valid