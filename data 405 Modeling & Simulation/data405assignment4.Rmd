---
title: "Data 405 Assignment 4 2025W"
output:
  pdf_document: default
  html_document: default
date: "2025-9-25"
---


# Data 405 Assignment 4

## Q1 code:

```{r}

set.seed(2025)

# load data
data(EuStockMarkets)
DAX <- EuStockMarkets[, "DAX"]

# (a) store dat in object
DAXlogreturn <- diff(log(DAX))

# (b) find drift (the mean of log-returns)
drift <- mean(DAXlogreturn)

# (c) acf of log-returns (the lin dependence)
pdf(NULL)
ansc <- acf(DAXlogreturn, main = "ACF of DAX log-returns")
ansc

# (d) acf of log-returns ^2 (prove of ARCH)
ansd <- acf(DAXlogreturn^2, main = "ACF of ^2 DAX log-returns")
ansd

# (e) fit AR(2) to ^2 returns to obtain approx ARCH(2) parameters
out <- arima(DAXlogreturn^2, order = c(2, 0, 0), include.mean=TRUE)
print(out)

# extract coef
phi <- as.numeric(out$coef[1:2])     # phi1, phi2 from AR(2) on ^2 series
xbar <- as.numeric(out$coef["intercept"]) # intercept (mean) from arima on ^2 series
s2 <- out$sigma2
cat("phi1 =", phi[1], " phi2 =", phi[2], " intercept =", xbar, " sigma2 =", s2, "\n")

# write out fitted AR(2) model for ^2 returns:
# y_t^2 = intercept + phi1 * y_{t-1}^2 + phi2 * y_{t-2}^2 + error_t
cat("\nfitted AR(2) on ^2 returns:\n")
cat(sprintf("y_t^2 = %g + (%g) y_{t-1}^2 + (%g) y_{t-2}^2 + eps_t\n",
            xbar, phi[1], phi[2]))

# (f) approximate ARCH(2) model using phi estimates:
# conditional variance: a0 + a1*y_{t-1}^2 + a2*y_{t-2}^2
# where a0 = intercept, a1 = phi1, a2 = phi2 (approx)

cat("\nApproximate ARCH(2):\n")
cat(sprintf("sigma_t^2 = %g + %g * y_{t-1}^2 + %g * y_{t-2}^2\n", xbar, phi[1], phi[2]))

```


### Q1b

Mean log-return (drift): `0.0006520417`

### Q1c ACF of raw returns:

No meaningful autocorrelation. All values are near 0. Conclusion: No linear dependence.

### Q1d, ACF of squared returns:

Clear positive autocorrelation at lag 1 (~0.079) and lag 2 (~0.171), and smaller positive values at later lags.
Conclusion: Strong evidence of volatility clustering.

### Q1e AR(2) fit:

```
y_t^2 = 0.000106487
+ 0.0658011 * y_{t-1}^2
+ 0.166083  * y_{t-2}^2
+ eps_t
```

### Q1f Approximate ARCH model:

```
Ïƒ_t^2 = 0.000106487
+ 0.166083  * y_{t-2}^2
+ 0.0658011 * y_{t-1}^2
```

### Q1g:

``` {r}
# (g) simulate a time series with same length and include drift
n <- length(DAX)
y <- numeric(n)
# init first two values with actual first two log-returns
y[1:2] <- DAXlogreturn[1:2]
Z <- rnorm(n)

for (i in 3:n) {
  condvar <- xbar + phi[1]*y[i-1]^2 + phi[2]*y[i-2]^2
  condvar <- ifelse(condvar > 0, condvar, 1e-8) # guard against tiny/negative
  s <- sqrt(condvar) * Z[i]
  y[i] <- s
}

# add drift & re-accumulate to prices
y_with_drift <- c(log(DAX[1]), y + drift)
DAXsim <- exp(cumsum(y_with_drift))

# plot real vs simulated
par(mfrow = c(1,2))
ts.plot(DAX, main = "Original DAX", ylab = "Index")
ts.plot(DAXsim, main = "Simulated DAX (ARCH(2) approx)", ylab = "Index")
par(mfrow = c(1,1))

# quick diagnostics: compare empirical acf of ^2 returns real vs simulated
par(mfrow = c(1,2))
acf(DAXlogreturn^2, main = "ACF ^2 (original)")
acf((diff(log(DAXsim)))^2, main = "ACF ^2 (simulated)")
par(mfrow = c(1,1))

# prin summary outputs
cat("\ndrift (mean log-return):", drift, "\n")
cat("length of series N:", n)

```

output:

```
drift (mean log-return): 0.0006520417 
length of series N: 1860
```

see data405assignment4q1ga.png and data405assignment4q1gb.png for plots 


